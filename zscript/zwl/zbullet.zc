class ZBullet : FastProjectile
{
    // These constants can be used to convert to Doom's natural units.
    // Assumes that 35 map units = 1 meter
    // e.g. 1*mps = 1 unit/tic
    const mps = 1;
    const fps = 0.3048;

    double airFriction;
    class<Actor> puffType;

    Property AirFriction : airFriction;
    Property PuffType : puffType;

    Default
    {
        Radius 1;
        Height 1;
        Decal "BulletChip";
        ZBullet.AirFriction 0.97;
        ZBullet.PuffType "ZBulletPuff";

        -NoGravity;
    }

    States
    {
    Death:  // Wall
    Crash:  // Non-bleeding actor
        TNT1 A 0 SpawnPuff(puffType, pos, angle, 0, 0);
        Stop;
    XDeath: // Bleeding actor
        TNT1 A 0;
        Stop;
    }

    override void Tick()
    {
        Super.Tick();

        vel *= airFriction;
        if (!bNoGravity)
            vel.z -= gravity * curSector.gravity;
    }
}


/*
    This is a modified version of Belmondo's tracer script.

	TRACER SYSTEM FOR ZSCRIPT 2.4 | APRIL 7TH 2017
	AUTHOR: (DENIS) BELMONDO

	USAGE: make a new class, inherit from ZTracer and change the properties as
		   you wish.

	you may use this in your project. just leave this comment at the top of
	this script and give credit please! thank you :^)

*/

class ZTracer : ZBullet
{

	const TRACERDURATION	= 1; // tics

    double tailLength;
    double particleScale;
    double particleSpacing;
    Color headColor, tailColor;

    Property TailLength : tailLength;
    Property ParticleScale : particleScale;
    Property ParticleSpacing : particleSpacing;
    Property Colors : headColor, tailColor;


    Default
    {
        ZTracer.TailLength 1.0;
        ZTracer.ParticleScale 4.0;
        ZTracer.ParticleSpacing 1.0;
        ZTracer.Colors 0xffff73, 0x9b5b13;
    }

    States
    {
    Spawn:
        TNT1 A 1 Light("TracerGlow");
        Loop;
    }


	override void Tick()
	{

		if (level.frozen || globalfreeze) return;

        for (double i = 0; i < vel.Length(); i += particleSpacing / tailLength)
        {
            double t = i / vel.Length();

            // As long as we have a lerp function, we may as well lerp the color, too
            Color col;
            if (1.25 * t < 1.0)
                col = int(Lerp(tailColor.r, headColor.r, 1.25 * t)) << 16
                    | int(Lerp(tailColor.g, headColor.g, 1.25 * t)) << 8
                    | int(Lerp(tailColor.b, headColor.b, 1.25 * t));
            else
                col = headColor;

            A_SpawnParticle (
                col,
                SPF_FULLBRIGHT,
                TRACERDURATION,
                particleScale * t,
                0,
                Lerp(-tailLength * vel.x, 0, t),
                Lerp(-tailLength * vel.y, 0, t),
                Lerp(-tailLength * vel.z, 0, t),
                vel.x, vel.y, vel.z,
                0, 0, 0,
                1.0
            );
        }

		Super.Tick();
	}

	// literally just stole this from wikipedia
	float lerp(float v0, float v1, float t) {
		return (1 - t) * v0 + t * v1;
	}
}